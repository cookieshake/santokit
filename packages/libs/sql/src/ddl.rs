//! DDL 생성기
//!
//! Schema IR을 기반으로 CREATE TABLE 등의 DDL을 생성합니다.

use stk_core::id::IdStrategy;
use stk_core::schema::{Column, ReferentialAction, Table};

/// DDL 생성기
pub struct DdlGenerator;

impl DdlGenerator {
    /// CREATE TABLE SQL 생성 (Postgres)
    pub fn create_table(table: &Table) -> String {
        let mut sql = format!("CREATE TABLE \"{}\" (\n", table.name);

        // PK 컬럼
        let pk_type = Self::id_column_ddl(&table.id);
        sql.push_str(&format!("    \"{}\" {} PRIMARY KEY", table.id.name, pk_type));

        // 일반 컬럼들
        for column in &table.columns {
            sql.push_str(",\n");
            sql.push_str(&Self::column_ddl(column));
        }

        sql.push_str("\n);\n");

        // 인덱스들
        for (i, index) in table.indexes.iter().enumerate() {
            let index_name = index
                .name
                .clone()
                .unwrap_or_else(|| format!("{}_{}_idx", table.name, i));

            let unique = if index.unique { "UNIQUE " } else { "" };
            let columns: Vec<String> = index.columns.iter().map(|c| format!("\"{}\"", c)).collect();

            sql.push_str(&format!(
                "CREATE {}INDEX \"{}\" ON \"{}\" ({});\n",
                unique,
                index_name,
                table.name,
                columns.join(", ")
            ));
        }

        // 외래키 제약
        for column in table.columns_with_references() {
            if let Some(ref reference) = column.references {
                let fk_name = format!("{}_{}_fkey", table.name, column.name);
                let ref_column = reference
                    .column
                    .as_deref()
                    .unwrap_or("id");

                sql.push_str(&format!(
                    "ALTER TABLE \"{}\" ADD CONSTRAINT \"{}\" FOREIGN KEY (\"{}\") REFERENCES \"{}\"(\"{}\") ON DELETE {} ON UPDATE {};\n",
                    table.name,
                    fk_name,
                    column.name,
                    reference.table,
                    ref_column,
                    Self::referential_action_ddl(reference.on_delete),
                    Self::referential_action_ddl(reference.on_update),
                ));
            }
        }

        sql
    }

    /// ID 컬럼 DDL
    fn id_column_ddl(id: &stk_core::schema::IdColumn) -> String {
        match id.generate {
            IdStrategy::AutoIncrement => "BIGINT GENERATED BY DEFAULT AS IDENTITY".to_string(),
            _ => "TEXT".to_string(),
        }
    }

    /// 일반 컬럼 DDL
    fn column_ddl(column: &Column) -> String {
        let mut parts = vec![format!("    \"{}\"", column.name)];

        // 타입
        parts.push(column.column_type.to_postgres_type());

        // NOT NULL
        if !column.nullable {
            parts.push("NOT NULL".to_string());
        }

        // UNIQUE
        if column.unique {
            parts.push("UNIQUE".to_string());
        }

        // DEFAULT
        if let Some(default) = &column.default {
            let default_expr = Self::default_value_ddl(default);
            parts.push(format!("DEFAULT {}", default_expr));
        }

        parts.join(" ")
    }

    /// DEFAULT 값 DDL
    fn default_value_ddl(default: &str) -> String {
        match default {
            "now" | "now()" => "NOW()".to_string(),
            "true" => "TRUE".to_string(),
            "false" => "FALSE".to_string(),
            s if s.starts_with('\'') => s.to_string(),
            s if s.parse::<i64>().is_ok() => s.to_string(),
            s if s.parse::<f64>().is_ok() => s.to_string(),
            s => format!("'{}'", s.replace('\'', "''")),
        }
    }

    /// Referential Action DDL
    fn referential_action_ddl(action: ReferentialAction) -> &'static str {
        action.to_postgres()
    }

    /// DROP TABLE SQL 생성
    pub fn drop_table(table_name: &str) -> String {
        format!("DROP TABLE IF EXISTS \"{}\" CASCADE;\n", table_name)
    }

    /// ADD COLUMN SQL 생성
    pub fn add_column(table_name: &str, column: &Column) -> String {
        let col_ddl = Self::column_ddl(column);
        // "    " prefix 제거
        let col_ddl = col_ddl.trim_start();
        format!("ALTER TABLE \"{}\" ADD COLUMN {};\n", table_name, col_ddl)
    }

    /// DROP COLUMN SQL 생성
    pub fn drop_column(table_name: &str, column_name: &str) -> String {
        format!(
            "ALTER TABLE \"{}\" DROP COLUMN IF EXISTS \"{}\";\n",
            table_name, column_name
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use stk_core::schema::{ColumnType, IdColumn, Index};

    #[test]
    fn test_create_table_basic() {
        let table = Table {
            name: "users".to_string(),
            connection: "main".to_string(),
            id: IdColumn::default(),
            columns: vec![
                Column {
                    name: "email".to_string(),
                    column_type: ColumnType::String,
                    nullable: false,
                    unique: true,
                    default: None,
                    references: None,
                },
                Column {
                    name: "created_at".to_string(),
                    column_type: ColumnType::Timestamp,
                    nullable: false,
                    unique: false,
                    default: Some("now".to_string()),
                    references: None,
                },
            ],
            indexes: vec![],
        };

        let ddl = DdlGenerator::create_table(&table);

        assert!(ddl.contains("CREATE TABLE \"users\""));
        assert!(ddl.contains("\"id\" TEXT PRIMARY KEY"));
        assert!(ddl.contains("\"email\" TEXT NOT NULL UNIQUE"));
        assert!(ddl.contains("\"created_at\" TIMESTAMPTZ NOT NULL DEFAULT NOW()"));
    }

    #[test]
    fn test_create_table_with_index() {
        let table = Table {
            name: "posts".to_string(),
            connection: "main".to_string(),
            id: IdColumn::default(),
            columns: vec![Column {
                name: "user_id".to_string(),
                column_type: ColumnType::String,
                nullable: false,
                unique: false,
                default: None,
                references: None,
            }],
            indexes: vec![Index {
                name: Some("posts_user_id_idx".to_string()),
                columns: vec!["user_id".to_string()],
                unique: false,
            }],
        };

        let ddl = DdlGenerator::create_table(&table);
        assert!(ddl.contains("CREATE INDEX \"posts_user_id_idx\""));
    }

    #[test]
    fn test_auto_increment_id() {
        let table = Table {
            name: "counters".to_string(),
            connection: "main".to_string(),
            id: IdColumn {
                name: "id".to_string(),
                generate: IdStrategy::AutoIncrement,
            },
            columns: vec![],
            indexes: vec![],
        };

        let ddl = DdlGenerator::create_table(&table);
        assert!(ddl.contains("BIGINT GENERATED BY DEFAULT AS IDENTITY"));
    }
}
