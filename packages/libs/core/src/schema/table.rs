//! 테이블 정의
//!
//! 선언 스키마의 테이블 메타데이터를 정의합니다.

use serde::{Deserialize, Serialize};

use super::column::Column;
use crate::id::IdStrategy;

/// 테이블 정의
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Table {
    /// 테이블 이름
    pub name: String,

    /// 연결된 connection 이름 (Hub에 등록된 이름)
    #[serde(default = "default_connection")]
    pub connection: String,

    /// PK 컬럼 정의
    pub id: IdColumn,

    /// 일반 컬럼들
    #[serde(default)]
    pub columns: Vec<Column>,

    /// 인덱스 정의
    #[serde(default)]
    pub indexes: Vec<Index>,
}

fn default_connection() -> String {
    "main".to_string()
}

/// PK 컬럼 정의
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IdColumn {
    /// PK 컬럼 이름 (기본: "id")
    #[serde(default = "default_id_name")]
    pub name: String,

    /// ID 생성 전략
    #[serde(default)]
    pub generate: IdStrategy,
}

fn default_id_name() -> String {
    "id".to_string()
}

impl Default for IdColumn {
    fn default() -> Self {
        Self {
            name: default_id_name(),
            generate: IdStrategy::default(),
        }
    }
}

impl IdColumn {
    /// 이 ID 컬럼의 논리적 타입
    pub fn column_type(&self) -> &'static str {
        self.generate.default_type()
    }

    /// Postgres 타입 문자열
    pub fn to_postgres_type(&self) -> &'static str {
        match self.generate {
            IdStrategy::AutoIncrement => "BIGINT GENERATED BY DEFAULT AS IDENTITY",
            _ => "TEXT",
        }
    }
}

/// 인덱스 정의
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Index {
    /// 인덱스 이름 (생략 시 자동 생성)
    #[serde(default)]
    pub name: Option<String>,

    /// 인덱스 대상 컬럼들
    pub columns: Vec<String>,

    /// 유니크 인덱스 여부
    #[serde(default)]
    pub unique: bool,
}

impl Table {
    /// 테이블의 모든 컬럼 이름 목록 (PK 포함)
    pub fn all_column_names(&self) -> Vec<&str> {
        let mut names = vec![self.id.name.as_str()];
        names.extend(self.columns.iter().map(|c| c.name.as_str()));
        names
    }

    /// 컬럼 이름으로 컬럼 찾기 (PK 제외)
    pub fn find_column(&self, name: &str) -> Option<&Column> {
        self.columns.iter().find(|c| c.name == name)
    }

    /// 이 테이블이 특정 connection에 속하는지
    pub fn belongs_to_connection(&self, connection: &str) -> bool {
        self.connection == connection
    }

    /// 외래키 참조가 있는 컬럼들
    pub fn columns_with_references(&self) -> impl Iterator<Item = &Column> {
        self.columns.iter().filter(|c| c.references.is_some())
    }

    /// SELECT * 시 반환할 컬럼들
    pub fn selectable_columns(&self) -> impl Iterator<Item = &Column> {
        self.columns.iter().filter(|c| c.included_in_select_all())
    }

    /// Insert/Update 가능한 컬럼들
    pub fn writable_columns(&self) -> impl Iterator<Item = &Column> {
        self.columns.iter().filter(|c| c.allows_write())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_table() -> Table {
        Table {
            name: "users".to_string(),
            connection: "main".to_string(),
            id: IdColumn::default(),
            columns: vec![
                Column {
                    name: "email".to_string(),
                    column_type: super::super::types::ColumnType::String,
                    nullable: false,
                    unique: true,
                    default: None,
                    references: None,
                },
                Column {
                    name: "_created_at".to_string(),
                    column_type: super::super::types::ColumnType::Timestamp,
                    nullable: false,
                    unique: false,
                    default: Some("now".to_string()),
                    references: None,
                },
            ],
            indexes: vec![],
        }
    }

    #[test]
    fn test_all_column_names() {
        let table = sample_table();
        let names = table.all_column_names();
        assert_eq!(names, vec!["id", "email", "_created_at"]);
    }

    #[test]
    fn test_writable_columns() {
        let table = sample_table();
        let writable: Vec<_> = table.writable_columns().collect();
        assert_eq!(writable.len(), 1);
        assert_eq!(writable[0].name, "email");
    }
}
