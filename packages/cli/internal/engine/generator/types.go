package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/cookieshake/santokit/packages/cli/internal/engine/integrator"
)

// GenerateTypes generates TypeScript definitions from the manifest
func GenerateTypes(manifest *integrator.Manifest) string {
	var sb strings.Builder

	sb.WriteString("// This file is auto-generated by Santokit CLI.\n")
	sb.WriteString("// Do not edit manually.\n\n")
	sb.WriteString("import '@santokit/client';\n\n")
	sb.WriteString("declare module '@santokit/client' {\n")
	sb.WriteString("  interface LogicNamespace {\n")

	// Group bundles by namespace
	namespaces := make(map[string][]integrator.Bundle)
	for _, bundle := range manifest.Bundles {
		if bundle.Type != integrator.BundleTypeLogic && bundle.Type != "js" && bundle.Type != "sql" {
			continue
		}
		namespaces[bundle.Namespace] = append(namespaces[bundle.Namespace], bundle)
	}

	// Sort namespaces for deterministic output
	var sortedNamespaces []string
	for ns := range namespaces {
		sortedNamespaces = append(sortedNamespaces, ns)
	}
	sort.Strings(sortedNamespaces)

	for _, ns := range sortedNamespaces {
		bundles := namespaces[ns]
		// Convert dot notation to nested objects if needed,
		// but for now let's assume flat namespace property or handle simple grouping.
		// "users" -> users: { ... }

		// If namespace has slashes, we might need nested structure,
		// but `LogicNamespace` structure implies we might want flat or structured.
		// The client SDK example shows `stk.logic.users.get()`.
		// So `users` is the namespace.

		parts := strings.Split(ns, "/")
		indent := 4

		// TODO: Handle nested namespaces properly.
		// For now, simple implementation assuming 1-level namespace (e.g. "users")
		// effectively mapping logic/users/get.js -> stk.logic.users.get

		// Using map to build tree could be better but let's stick to simple first

		sb.WriteString(fmt.Sprintf("%*s%s: {\n", indent, "", parts[len(parts)-1]))

		sort.Slice(bundles, func(i, j int) bool {
			return bundles[i].Name < bundles[j].Name
		})

		for _, bundle := range bundles {
			sb.WriteString(fmt.Sprintf("%*s%s: (params: {\n", indent+2, "", bundle.Name))

			// Params
			if params, ok := bundle.Config["params"].(map[string]interface{}); ok {
				// Sort params
				var paramNames []string
				for p := range params {
					paramNames = append(paramNames, p)
				}
				sort.Strings(paramNames)

				for _, pName := range paramNames {
					pConfig := params[pName].(map[string]interface{})
					pType := pConfig["type"].(string)
					pRequired := pConfig["required"].(bool)

					tsType := "any"
					switch pType {
					case "string":
						tsType = "string"
					case "int":
						tsType = "number"
					case "bool":
						tsType = "boolean"
					case "json":
						tsType = "any"
					}

					optional := "?"
					if pRequired {
						optional = ""
					}

					sb.WriteString(fmt.Sprintf("%*s%s%s: %s;\n", indent+4, "", pName, optional, tsType))
				}
			}

			sb.WriteString(fmt.Sprintf("%*s}) => Promise<any>;\n", indent+2, ""))
		}
		sb.WriteString(fmt.Sprintf("%*s};\n", indent, ""))
	}

	sb.WriteString("  }\n")
	sb.WriteString("}\n")

	return sb.String()
}
