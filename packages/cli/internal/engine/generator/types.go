package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/cookieshake/santokit/packages/cli/internal/engine/integrator"
)

// GenerateTypes generates TypeScript definitions from the manifest
func GenerateTypes(manifest *integrator.Manifest) string {
	var sb strings.Builder

	sb.WriteString("// This file is auto-generated by Santokit CLI.\n")
	sb.WriteString("// Do not edit manually.\n\n")
	sb.WriteString("import '@santokit/client';\n\n")
	sb.WriteString("declare module '@santokit/client' {\n")
	sb.WriteString("  interface LogicNamespace {\n")

	root := &namespaceNode{children: make(map[string]*namespaceNode)}

	for _, bundle := range manifest.Bundles {
		if bundle.Type != integrator.BundleTypeLogic && bundle.Type != "js" && bundle.Type != "sql" {
			continue
		}
		if strings.HasPrefix(bundle.Name, "_") {
			continue
		}

		ns := strings.Trim(bundle.Namespace, "/")
		parts := []string{}
		if ns != "" && ns != "." {
			parts = strings.Split(ns, "/")
		}

		current := root
		for _, part := range parts {
			if part == "" || part == "." {
				continue
			}
			child, ok := current.children[part]
			if !ok {
				child = &namespaceNode{children: make(map[string]*namespaceNode)}
				current.children[part] = child
			}
			current = child
		}
		current.bundles = append(current.bundles, bundle)
	}

	writeNamespace(&sb, root, 4)

	sb.WriteString("  }\n")
	sb.WriteString("}\n")

	return sb.String()
}

type namespaceNode struct {
	children map[string]*namespaceNode
	bundles  []integrator.Bundle
}

func writeNamespace(sb *strings.Builder, node *namespaceNode, indent int) {
	if len(node.bundles) > 0 {
		sort.Slice(node.bundles, func(i, j int) bool {
			return node.bundles[i].Name < node.bundles[j].Name
		})
		for _, bundle := range node.bundles {
			sb.WriteString(fmt.Sprintf("%*s%s: (params: {\n", indent, "", bundle.Name))

			// Params
			if params, ok := bundle.Config["params"].(map[string]interface{}); ok {
				// Sort params
				var paramNames []string
				for p := range params {
					paramNames = append(paramNames, p)
				}
				sort.Strings(paramNames)

				for _, pName := range paramNames {
					pConfig, ok := params[pName].(map[string]interface{})
					if !ok {
						continue
					}
					pType, _ := pConfig["type"].(string)
					pRequired, _ := pConfig["required"].(bool)

					tsType := "any"
					switch pType {
					case "string":
						tsType = "string"
					case "int":
						tsType = "number"
					case "bool":
						tsType = "boolean"
					case "json":
						tsType = "any"
					}

					optional := "?"
					if pRequired {
						optional = ""
					}

					sb.WriteString(fmt.Sprintf("%*s%s%s: %s;\n", indent+2, "", pName, optional, tsType))
				}
			}

			sb.WriteString(fmt.Sprintf("%*s}) => Promise<any>;\n", indent, ""))
		}
	}

	if len(node.children) == 0 {
		return
	}

	var childNames []string
	for name := range node.children {
		childNames = append(childNames, name)
	}
	sort.Strings(childNames)

	for _, name := range childNames {
		child := node.children[name]
		sb.WriteString(fmt.Sprintf("%*s%s: {\n", indent, "", name))
		writeNamespace(sb, child, indent+2)
		sb.WriteString(fmt.Sprintf("%*s};\n", indent, ""))
	}
}
