# Schema (Declarative YAML) — Spec

목표:
- Santokit의 스키마 Source of Truth는 선언 스키마(YAML)이다.
- Hub(Control Plane)가 선언 스키마를 기준으로 DB에 대해 **plan/apply**를 수행한다.
- destructive 변경은 허용하지 않는다.
- DB가 수동으로 변경되어 스키마 드리프트가 발생하면 **릴리즈를 차단**한다.

---

## 1) Source of Truth & Artifacts

Source of Truth:
- `schema/*.yaml` (YAML)

Hub가 생성/저장하는 파생 아티팩트:
- `schema_ir`(connection별): 선언 스키마를 파싱/검증한 내부 IR(엔진 중립)
- `ddl_plan`(connection별): 특정 DB 엔진(Postgres 등)에 대한 적용 계획(plan)
- `schema_snapshot`(connection별): 실제 DB 인트로스펙션 결과(검증/드리프트 감지용)

원칙:
- CRUD 실행은 `schema_ir`를 기준으로 한다.
- DB 인트로스펙션은 “검증/드리프트 감지/plan 계산” 목적이다.

---

## 2) YAML Format (Base Only)

파일 예시(스케치):
```yaml
version: 1

tables:
  users:
    connection: main
    id:
      name: id
      type: string
      generate: ulid
    columns:
      email: { type: string, nullable: false, unique: true }
      created_at: { type: timestamp, nullable: false, default: now }
    indexes:
      - columns: [email]
        unique: true
```

의미:
- `tables.<name>.connection`은 Hub에 등록된 connection name을 가리킨다.
- DB 엔진(`postgres` 등)은 **connection 설정**으로부터 결정한다(스키마 YAML에 엔진을 쓰지 않는다).

멀티 connection:
- 한 프로젝트가 여러 DB(connection)를 사용할 수 있다.
- `schema/*.yaml`는 여러 파일로 구성될 수 있다.
- Hub는 `tables.<name>.connection` 기준으로 테이블을 그룹핑해 `connection → schema_ir`을 만든다.
- 프로젝트 스키마 전체에서 `tables.<name>`은 **전역 유니크**여야 한다(충돌 시 에러).
- connection 간 foreign key/참조는 최종 스펙 범위 밖이다(= cross-DB 관계 금지).

기본형(Base)만 지원한다:
- tables / columns / unique / indexes / (optional) foreign keys
- 타입은 “logical type” 집합으로 제한한다.
- 엔진별 raw SQL escape/확장 필드는 최종 스펙 범위 밖으로 둔다.

Primary Key / ID Column (Final):
- 복합키는 금지한다.
- 모든 테이블은 **단일 PK를 가진다**.
- PK 컬럼은 `tables.<name>.id`로 정의한다(권장).
  - `name`: PK 컬럼명 (default: `id`)
  - `generate`: `ulid` | `nanoid` | `uuid_v4` | `uuid_v7` | `auto_increment` | `client` (default: `ulid`)
  - `type`: `string` | `bigint` (optional; 아래 규칙 참고)
- `columns`에는 PK 컬럼을 중복 정의할 수 없다(정의 시 에러).
- `generate` 해석:
  - `ulid|uuid_v7`: Bridge가 `insert` 시 값을 생성한다(클라이언트가 `id`를 보내면 기본적으로 거부).
  - `client`: 클라이언트/서버가 `id`를 제공해야 한다(Bridge는 생성하지 않는다).

`generate` ↔ `type` 규칙(단순화):
- `generate=ulid|nanoid|uuid_v4|uuid_v7`이면 `type`은 **항상 `string`** 으로 고정한다(`type` 명시 시에도 무시/에러).
- `generate=auto_increment`이면 `type`은 **항상 `bigint`** 로 고정한다.
- `generate=client`일 때만 `type`을 선택할 수 있다:
  - `type` 생략 시 default는 `string`
  - `type=bigint`를 쓰고 싶으면 `generate=client`를 사용한다(서버/클라가 값을 채워 넣는 모델).

`auto_increment` (DB-generated integer id):
- 의미: DB가 insert 시 PK를 자동 생성한다.
- 엔진 매핑(예: Postgres):
  - `GENERATED BY DEFAULT AS IDENTITY`(권장) 또는 동등한 메커니즘으로 컴파일한다.

Foreign Keys (Optional):
- 목적: referential integrity를 DB에서 강제하고, 스키마 검증/드리프트 감지의 기준으로 사용한다.
- FK는 Auto CRUD의 필수 요건은 아니다(예: `user_id` 컬럼은 FK 없이도 존재/사용 가능).
- 제약:
  - FK는 **같은 connection** 안에서만 허용한다(cross-DB FK 금지).
  - 참조 대상 `table/column`은 선언 스키마에 존재해야 한다.

예(스케치):
```yaml
version: 1

tables:
  posts:
    connection: main
    id: { name: id, type: string, generate: ulid }
    columns:
      user_id:
        type: string
        nullable: false
        references:
          table: users
          as: user
          onDelete: cascade
          onUpdate: restrict
```

`references`:
- 형식: `{ table: <tableName>, column: <columnName>, as?: <relationName>, onDelete?: <policy>, onUpdate?: <policy> }`
- `as`는 Auto CRUD의 `expand`에서 사용할 “관계 이름”이다(선택).
- `onDelete/onUpdate`는 DB 레벨 referential action 정책이다(선택).
  - 허용 정책: `restrict` | `no_action` | `cascade` | `set_null` | `set_default`
  - 기본값(권장): `restrict`
- `column`이 생략되면 참조 대상 테이블의 `id.name`을 기본값으로 사용한다.

---

## 3) Logical Types (Core)

목표: 여러 DB 엔진으로 컴파일 가능한 공통 타입 집합을 유지한다.

Core types:
- `string`
- `int`
- `bigint`
- `float`
- `boolean`
- `json`
- `timestamp`
- `bytes`
- `array` (typed JSON array; see below)

엔진별 매핑은 Hub가 담당한다.

`array`:
- 목적: “배열”을 스키마 수준에서 명시하고, CRUD 입력/출력에서 타입 검증을 강화한다.
- 표기:
  - `type: array`와 함께 `items: <coreType>`을 필수로 둔다.
  - `items`는 또 다른 `array`가 될 수 있다(중첩 배열 허용).
- 엔진 매핑(기본):
  - 엔진 중립을 위해 기본 구현은 JSON 컬럼(`json/jsonb` 등)에 저장하는 것을 기준으로 한다.
  - 특정 엔진의 native array 타입 최적화는 추후 확장으로 둔다.

예(스케치):
```yaml
tables:
  posts:
    connection: main
    id: { name: id, type: string, generate: ulid }
    columns:
      tags: { type: array, items: string, nullable: false }
      scores: { type: array, items: int, nullable: true }
```

---

## 4) Plan / Apply (Hub 실행)

명령 주체:
- Operator가 `stk`로 Hub에 트리거한다.

CLI (최종 표면):
- `stk apply --only schema --dry-run --ref <ref>`
  - YAML 파싱/규칙 검증 + 엔진별 컴파일 가능성 확인
  - Hub가 DB 인트로스펙션 → diff → plan 생성(출력)
- `stk apply --only schema --ref <ref>`
  - Hub가 “허용된 subset”만 DB에 적용

멀티 connection 동작:
- `schema/*.yaml`에 등장하는 모든 connection에 대해 plan/apply를 수행한다.

허용되는 apply subset(비파괴):
- create table
- add column (안전한 조건에서만)
- create index
- add foreign key constraint (기존 데이터가 위배하면 실패)

금지(Destructive):
- drop table/column/index
- rename table/column
- column type change
- drop/alter foreign key constraint
- nullable 감소(예: nullable=true → false)
- 의미가 불명확한 변경은 기본적으로 차단

---

## 5) Drift Policy (Release Gate)

드리프트 정의:
- 선언 스키마 기준 예상 상태와 실제 DB 상태가 다를 때

정책:
- 드리프트가 존재하면 해당 `project+env`에 대해 “릴리즈 생성/승격”을 차단한다.
  - 예: `stk apply`가 `release` 단계를 포함하면 실패해야 한다.
  - 예: `stk release promote`는 실패해야 한다.
- Operator는 먼저 `stk apply --only schema ...`로 정합성을 회복하거나, 선언 스키마를 수정해야 한다.

멀티 connection:
- 드리프트는 connection별로 판단한다.
- `schema/*.yaml`에 포함된 connection 중 하나라도 드리프트가 있으면 릴리즈 생성/승격을 차단한다.

---

## 6) Multi-Engine Note

DB 엔진은 추후 추가될 수 있다.
원칙:
- YAML은 엔진 중립을 유지한다(핵심 logical types + base primitives).
- 엔진별 차이가 큰 기능은 최종 스펙에 포함하지 않는다.
