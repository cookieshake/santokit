# Schema (Declarative YAML) — Spec

## 1) Source of Truth & Artifacts

Source of Truth:
- `schema/*.yaml` (YAML)

Hub가 생성/저장하는 파생 아티팩트:
- `schema_ir` (connection별): 선언 스키마를 파싱/검증한 내부 IR (엔진 중립)
- `ddl_plan` (connection별): 특정 DB 엔진에 대한 적용 계획
- `schema_snapshot` (connection별): 실제 DB 인트로스펙션 결과 (검증/드리프트 감지용)

원칙:
- CRUD 실행은 `schema_ir`를 기준으로 한다.
- DB 인트로스펙션은 "검증/드리프트 감지/plan 계산" 목적이다.

---

## 2) YAML Format

### Base Structure

```yaml
version: 1

tables:
  users:
    connection: main
    id:
      name: id
      type: string
      generate: ulid
    columns:
      email: { type: string, nullable: false, unique: true }
      created_at: { type: timestamp, nullable: false, default: now }
    indexes:
      - columns: [email]
        unique: true
```

- `tables.<name>.connection`: Hub에 등록된 connection name을 가리킨다.
- DB 엔진 (`postgres` 등)은 connection 설정으로부터 결정한다 (스키마 YAML에 엔진을 쓰지 않는다).

### Multi-Connection

- 한 프로젝트가 여러 DB (connection)를 사용할 수 있다.
- `schema/*.yaml`는 여러 파일로 구성될 수 있다.
- Hub는 `tables.<name>.connection` 기준으로 테이블을 그룹핑해 `connection → schema_ir`을 만든다.
- 프로젝트 스키마 전체에서 `tables.<name>`은 전역 유니크여야 한다 (충돌 시 에러).
- Cross-DB foreign key/참조는 지원하지 않는다.

### Primary Key / ID Column

- 복합키는 금지한다. 모든 테이블은 단일 PK를 가진다.
- PK 컬럼은 `tables.<name>.id`로 정의한다 (권장).
  - `name`: PK 컬럼명 (default: `id`)
  - `generate`: `ulid` | `nanoid` | `uuid_v4` | `uuid_v7` | `auto_increment` | `client` (default: `ulid`)
  - `type`: `string` | `bigint` (아래 규칙 참고)
- `columns`에 PK 컬럼을 중복 정의하면 에러.

`generate` ↔ `type` 규칙:
- `ulid` | `nanoid` | `uuid_v4` | `uuid_v7`: `type`은 항상 `string` (명시해도 무시/에러).
- `auto_increment`: `type`은 항상 `bigint`. 엔진 매핑 예: Postgres `GENERATED BY DEFAULT AS IDENTITY`.
- `client`: `type`을 선택할 수 있다. 생략 시 default `string`.

`generate` 동작:
- `ulid` | `uuid_v7`: Bridge가 `insert` 시 값을 생성 (클라이언트가 `id`를 보내면 기본적으로 거부).
- `client`: 클라이언트/서버가 `id`를 제공해야 한다 (Bridge는 생성하지 않는다).

### Foreign Keys

목적: referential integrity를 DB에서 강제하고, 스키마 검증/드리프트 감지의 기준으로 사용한다. FK는 Auto CRUD의 필수 요건이 아니다.

제약:
- FK는 같은 connection 안에서만 허용한다.
- 참조 대상 `table/column`은 선언 스키마에 존재해야 한다.

```yaml
tables:
  posts:
    connection: main
    id: { name: id, type: string, generate: ulid }
    columns:
      user_id:
        type: string
        nullable: false
        references:
          table: users
          as: user
          onDelete: cascade
          onUpdate: restrict
```

`references` 형식: `{ table: <tableName>, column?: <columnName>, as?: <relationName>, onDelete?: <policy>, onUpdate?: <policy> }`

- `column` 생략 시: 참조 대상 테이블의 `id.name`을 기본값으로 사용.
- `as`: Auto CRUD의 `expand`에서 사용할 관계 이름 (선택).
- `onDelete` / `onUpdate`: DB 레벨 referential action 정책 (선택). 기본값 권장: `restrict`.
  - 허용 정책: `restrict` | `no_action` | `cascade` | `set_null` | `set_default`

---

## 3) Logical Types

목표: 여러 DB 엔진으로 컴파일 가능한 공통 타입 집합을 유지한다. 엔진별 매핑은 Hub가 담당한다.

| Type | JSON wire format | 비고 |
|------|-----------------|------|
| `string` | `string` | |
| `int` | `number` | |
| `bigint` | `string` | 64-bit 정밀도 보장 |
| `float` | `number` | 64-bit Double Precision |
| `decimal` | `string` | 고정 소수점, 정밀도 보장 |
| `boolean` | `boolean` | |
| `json` | any JSON value | |
| `timestamp` | `string` | ISO 8601 |
| `bytes` | `string` | RFC4648 base64 |
| `file` | `string` | storage path; 아래 참고 |
| `array` | JSON array | typed; 아래 참고 |

### `array`

- `type: array`와 함께 `items: <coreType>`을 필수로 지정한다.
- `items`는 또 다른 `array`가 될 수 있다 (중첩 허용).
- 엔진 중립 기본 구현: JSON 컬럼 (`json/jsonb` 등)에 저장. native array 최적화는 추후 확장.

```yaml
columns:
  tags: { type: array, items: string, nullable: false }
  scores: { type: array, items: int, nullable: true }
```

### `file`

- Storage에 저장된 파일의 경로(string)를 담는 컬럼이다.
- 속성:
  - `bucket`: 대상 버킷 alias (필수)
  - `onDelete`: Row 삭제 시 파일 처리 정책 (선택)
    - `preserve` (default): 파일을 스토리지에 그대로 남긴다.
    - `cascade`: 스토리지에서 해당 파일도 삭제한다.

```yaml
avatar:
  type: file
  bucket: main
  onDelete: cascade
```

---

## 4) Plan / Apply

### Safe Alter (기본 허용)

- `CREATE TABLE`
- `ADD COLUMN` (nullable 또는 default 있음)
- `CREATE INDEX`
- `ADD FOREIGN KEY` (기존 데이터가 위배하면 실패)

### Explicit Destructive (`--force` 필요)

- `DROP TABLE` / `DROP COLUMN` / `DROP INDEX`
- 제약 조건 강화 (예: Nullable → Not Null; 데이터 위배 시 실패)
- 단순 통/폐합 (table re-create)

### Complex Casting (미지원)

- 데이터 변환 로직이 필요한 형변환 (예: `text` → `int`)
- Santokit은 마이그레이션 스크립트를 실행하지 않는다. 사용자가 (1) 컬럼을 drop 후 재생성하거나 (2) 수동으로 데이터를 정리해야 한다.

### Rollback 정책

- **스키마 rollback (down migration)은 지원하지 않는다** (by design; 데이터 손실 위험 및 복잡도).
- `release rollback`: Hub의 current release 포인터를 이전 `releaseId`로 이동하는 운영 동작 (지원; OPERATOR-005).
- **Forward-only migration** 정책: 문제 발생 시 새로운 마이그레이션으로 수정 (hotfix).

권장:
- Production 반영 전 dev/staging에서 검증.
- 파괴적 변경은 `--dry-run`으로 preview 확인 후 적용.
- Critical 데이터는 apply 전 백업.

---

## 5) Drift Policy

드리프트 정의: 선언 스키마 기준 예상 상태와 실제 DB 상태가 다를 때.

정책:
- 드리프트가 존재하면 해당 `project+env`에 대해 릴리즈 생성/승격을 차단한다.
- Operator는 먼저 `stk apply --only schema`로 정합성을 회복하거나 선언 스키마를 수정해야 한다.

Multi-connection:
- 드리프트는 connection별로 판단한다.
- `schema/*.yaml`에 포함된 connection 중 하나라도 드리프트가 있으면 릴리즈 생성/승격을 차단한다.

---

## 6) Multi-Engine Neutrality

- YAML은 엔진 중립을 유지한다 (logical types + base primitives).
- DB 엔진 (`postgres` 등)은 connection 설정에서만 결정된다.
- 엔진별 차이가 큰 기능은 최종 스펙에 포함하지 않는다.
- 엔진 추가 시 YAML 선언은 변경 없이 Hub의 컴파일 로직만 확장된다.
